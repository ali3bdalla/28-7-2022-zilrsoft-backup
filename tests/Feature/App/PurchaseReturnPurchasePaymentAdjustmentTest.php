<?php

namespace Tests\Feature\App;

use App\Models\Account;
use App\Models\Invoice;
use App\Models\Manager;
use App\Models\TransactionsContainer;
use Illuminate\Support\Facades\DB;
use Tests\TestCase;

class PurchaseReturnPurchasePaymentAdjustmentTest extends TestCase
{

    private $dbConnection;

    protected function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        $this->dbConnection = DB::connection('data_source');

    }

    /**
     * A basic feature test example.
     *
     * @return void
     */
    public function test_purchase_and_return_purchase_payments()
    {

        $invoices = $this->dbConnection->table('invoices')->whereIn('invoice_type', ['purchase', 'r_purchase'])->get();
        $tempResellerAccount = Account::where('slug', 'temp_reseller_account')->first();
        $vendorAccount = Account::where('slug', 'vendors')->first();

        $manager = Manager::find(1);
        foreach ($invoices as $invoice) {
            $paymentAmount = $this->dbConnection->table('payments')->where('invoice_id', $invoice->id)->sum('amount');
            if ($paymentAmount > 0) {
                $newInvoice = Invoice::find($invoice->new_db_id);

                if ($newInvoice) {

                    $user = $newInvoice->user;

                    if ($newInvoice->invoice_type == 'purchase') {
                        $transactions = [
                            [
                                'id' => $vendorAccount->id,
                                'user_id' => $user->id,
                                'type' => 'debit',
                                'amount' => $newInvoice->net,

                            ],
                            [
                                'id' => $tempResellerAccount->id,
                                'amount' => $newInvoice->net,
                                'type' => 'credit',
                            ],
                        ];
                    }

                    if ($newInvoice->invoice_type == 'return_purchase') {
                        $transactions = [
                            [
                                'id' => $vendorAccount->id,
                                'user_id' => $user->id,
                                'type' => 'credit',
                                'amount' => $newInvoice->net,

                            ],
                            [
                                'id' => $tempResellerAccount->id,
                                'amount' => $newInvoice->net,
                                'type' => 'debit',
                            ],
                        ];
                    }

                    $response = $this->actingAs($manager)->postJson('/api/entities', [
                        'transactions' => $transactions,
                        'description' => 'payment for invoice # ' . $newInvoice->invoice_number,
                    ]);

                    $response->dump()->assertCreated();
                    $entity = json_decode($response->content(), true);

                    $createdEntity = TransactionsContainer::find($entity['id']);

                    $createdEntity->update([
                        'created_at' => $invoice->created_at,
                    ]);

                    $createdEntity->transactions()->update([
                        'created_at' => $invoice->created_at,
                    ]);

                }

// dd($paymentAmount);
            }

        }

        // $response = $this->get('/');

        // $response->assertStatus(200);
    }
}
